# 예약 및 대기열 기능 구현 보고서

## 1. 좌석 임시 배정 동시성 제어
### 문제 상황
여러 사용자가 동시에 같은 좌석을 예약하기 위해 좌석 점유를 요청할 때, 중복 예약이 발생할 수 있다.

### 해결 전략
단일 인스턴스에서 발생하는 중복 요청과 멀티 인스턴스에서 발생하는 동시성 제어를 수행했다. 
1. **단일 인스턴스 중복 요청 - 멱등성 처리**
    - 클라이언트가 제공한 `idempotencyKey`로 같은 클라이언트의 중복 요청을 방지한다.
    - `holdSeatIdempotencyCachePort.tryProcess()`가 Redis의 `setIfAbsent()`를 사용하여 Atomic하게 멱등성 키를 선점한다.
2. **멀티 인스턴스 동시성 제어 - 분산락**
    - 멱등성 키 검증을 통과할 경우 새로운 요청으로 간주하여 좌석 예약 요청을 수행한다.
    - `holdSeatCachePort.holdSeatList()`에서 좌석별로 Redis 분산락(RLock)을 획득하여 동시성을 제어한다.
    - 데드락을 방지하기 위해 좌석ID 기반으로 오름차순 정렬을 수행하여 순차적으로 락을 획득하도록 한다.
    - 여러 개의 좌석 예약 시도 시, 모든 좌석의 분산락을 획득해야만 전체 좌석을 점유 처리한다.
    - 만약 분산락을 하나라도 획득하지 못하거나, 점유하려는 좌석 중 이미 예약이 되어 있는 좌석이 있을 경우 분산락을 해제하고 로직을 벗어난다.
   (해제가 안 되더라도 Lease Time 10초 안으로 안전하게 해제되도록 설정함)
    - 모든 좌석 점유 성공 시 Redis에 15분(900초) TTL로 저장된다.
    - 최종적으로 멱등성 처리를 위해 결과를 `holdSeatIdempotencyCachePort.saveResult()`를 통해 멱등성 캐시에 저장한다.

### 테스트 결과
#### 1) 단위 테스트 (HoldSeatUseCaseTest.java)
**목적**: Mock 객체를 활용한 비즈니스 로직 검증 <br>
**파일**: `HoldSeatUseCaseTest.java`

| 카테고리 | 테스트 케이스 | 검증 내용 |
|---------|-------------|----------|
| **정상 동작** | 정상적인 좌석 예약 요청시 성공 | 멱등성 키 검증 → 홀딩 검증 → 좌석 점유 → TTL 조회 흐름 |
| | 동일한 요청 재시도 시 기존 결과 반환 | 이미 홀딩된 좌석 재요청 시 기존 TTL 반환 |
| **입력 검증** | 좌석 목록 null 예외 | null 좌석 리스트 예외 처리 |
| | 좌석 목록 empty 예외 | 빈 좌석 리스트 예외 처리 |
| | 중복 좌석ID 중복 제거 | [101,102,103,102,101] → [101,102,103] |
| **멱등성** | 멱등성키 null 예외 | null 멱등성 키 예외 처리 |
| | 멱등성키 빈값 예외 | 빈 문자열 멱등성 키 예외 처리 |
| | 멱등성키 캐시 조회 성공 | 동일 멱등성 키 재요청 시 캐시된 결과 반환 |
| | 멱등성 저장 실패 시 롤백 | 멱등성 캐시 저장 실패 시 전체 트랜잭션 롤백 |
| **동시성<br/>(Mock 기반)** | 다른 사용자 예약 중 예외 | `holdSeatList()` 실패 시 예외 발생 확인 |
| | 동일 좌석 동시 예약 (10 스레드) | Mock 설정으로 1건 성공, 9건 실패 검증 |
| | 각자 다른 좌석 동시 예약 (10 스레드) | 모든 스레드 성공 (10건) |

**총 13개 테스트 케이스** - 전체 ✅ 통과

---

#### 2) 통합 테스트 - 동시성 제어 (HoldSeatConcurrencyTest.java)
**목적**: 실제 Redis 환경에서 분산락 동시성 제어 검증 <br>
**파일**: `HoldSeatConcurrencyTest.java:27` <br>
**환경**: Redis TestContainers + Redisson 분산락

**테스트: 같은 좌석에 대해 동시 예약 요청 시 한명만 성공해야 한다**
```
시나리오: 100명의 사용자가 동일 좌석(1L, 2L, 3L)에 동시 예약 시도
멱등성 키: 각 요청마다 UUID 생성 (중복 요청 아님)

예상 결과:
  ✅ 성공: 1건 (분산락 획득 성공)
  ✅ 실패: 99건 ("다른 사용자가 이미 예약 중" 예외)

검증 완료: Redis 분산락이 멀티 인스턴스 환경에서도 정상 동작
```

---

#### 3) 통합 테스트 - TTL 만료 (HoldSeatTimeoutTest.java)
**목적**: Redis TTL 만료 후 재예약 가능 여부 검증 <br>
**파일**: `HoldSeatTimeoutTest.java:30`

**테스트: 좌석 홀딩 TTL 만료 후 다른 사용자가 예약할 수 있어야 한다**
```
시나리오:
  1. 사용자A (userId=100) → 좌석 1L, 2L 홀딩 성공
  2. Redis 키 TTL을 1초로 단축 (hold:1:1, hold:1:2)
  3. 1.1초 대기 → TTL 만료
  4. 사용자B (userId=200) → 동일 좌석 홀딩 시도

예상 결과:
  ✅ 사용자A 홀딩 성공
  ✅ TTL 만료 후 사용자B 홀딩 성공
  ✅ 사용자B 결과에 좌석 1L, 2L 포함 확인

검증 완료: Redis TTL 만료 시 분산락 자동 해제 및 재예약 가능
```

---

### 테스트 요약

| 테스트 유형 | 검증 항목 | 스레드 수 | 결과 |
|------------|----------|----------|------|
| 단위 테스트 | 비즈니스 로직 13가지 시나리오 | 10 | ✅ 전체 통과 |
| 통합 테스트 | Redis 분산락 동시성 제어 | 100 | ✅ 1건 성공, 99건 실패 |
| 통합 테스트 | TTL 만료 후 재예약 | 2 (순차) | ✅ A홀딩 → 만료 → B홀딩 성공 |

<br>
<br>
<br>

## 2. 대기열 입장 처리

### 문제 상황
콘서트 예약 시스템에서 동시 접속자가 급증할 경우, 서버 리소스를 초과하여 시스템 장애가 발생할 수 있다. 또한 여러 스케줄에 대해 동시에 입장 처리가 발생할 때 동시성 제어가 필요하다.

### 해결 전략
1. **세마포어 기반 진입 제어**
   - Redis Semaphore로 스케줄당 최대 100개의 동시 접속 Permit 제한
   - Permit 획득 성공 시 즉시 JWT 토큰 발급 및 입장 허용
   - Permit 획득 실패 시 Redis Sorted Set 기반 대기열에 진입

2. **분산락을 통한 입장 처리 동시성 제어**
   - 스케줄별 입장 처리 시 `admit:lock:reservation:{scheduleId}` 분산락 획득
   - 다중 인스턴스 환경에서 동일 스케줄에 대한 중복 입장 처리 방지
   - 락 획득 실패 시 해당 스케줄 입장 처리 건너뛰기

3. **병렬 처리 (parallelStream)**
   - 여러 활성 스케줄을 동시에 처리하여 입장 처리 성능 향상
   - 각 스케줄별로 독립적인 분산락으로 병렬 처리 가능

4. **보상 트랜잭션**
   - 토큰 발급 실패 시 대기열 재추가 및 Permit 반환
   - 데이터 정합성 보장

### 테스트 결과

#### 1) 단위 테스트 (ReservationWaitingServiceTest.java)
**목적**: Mock 객체를 활용한 대기열 비즈니스 로직 검증 <br>
**파일**: `ReservationWaitingServiceTest.java`

| 카테고리 | 테스트 케이스 | 검증 내용 |
|---------|-------------|----------|
| **입장 제어** | 즉시 입장 성공 | 대기열 비활성화 + 세마포어 획득 성공 → JWT 토큰 발급 |
| | 대기열 진입 (활성화 상태) | 대기열이 활성화되어 있으면 즉시 대기열 진입 |
| | 대기열 진입 (세마포어 실패) | 세마포어 획득 실패 시 대기열 진입 |
| **SSE 구독** | 정상 구독 | 유효한 userKey로 SSE emitter 생성 (10분 타임아웃) |
| | userId 불일치 예외 | userKey의 userId가 실제 userId와 다르면 예외 |
| | 잘못된 형식 예외 | userKey 형식이 잘못되면 예외 |
| **입장 처리<br/>(Scheduler)** | 활성 대기열 없음 | 활성 대기열이 없으면 입장 처리 수행 안 함 |
| | 분산락 실패 시 건너뛰기 | 분산락 획득 실패 시 해당 스케줄 입장 처리 건너뛰기 |
| | 토큰 발급 실패 보상 | JWT 생성 실패 시 대기열 재추가 + Permit 반환 |
| | 입장 처리 수 결정 | min(가용 Permit, 대기자 수)로 입장 처리 수 결정 |
| | 병렬 처리 검증 | parallelStream으로 여러 스케줄 동시 처리 |
| **이벤트 발행** | 상태 이벤트 발행 | 활성 스케줄별로 대기열 상태 이벤트 발행 |
| | 대기자 없음 시 제거 | 대기자가 없는 스케줄은 활성 목록에서 제거 |
| **SSE 알림** | 로컬 대기자만 알림 | 로컬 인스턴스에 연결된 대기자만 SSE 알림 전송 |
| | 순번 조회 실패 시 건너뛰기 | rank가 null이면 해당 사용자 건너뛰기 |

**총 15개 테스트 케이스** - 전체 ✅ 통과

---

#### 2) 통합 테스트 (WaitingAdmissionIntegrationTest.java)
**목적**: 실제 Redis 환경에서 대기열 입장 처리 검증 <br>
**파일**: `WaitingAdmissionIntegrationTest.java:42` <br>
**환경**: Redis TestContainers + Redisson Semaphore & Sorted Set

**테스트: 대기열에 있는 사용자를 입장처리 할 수 있어야 한다**
```
시나리오:
  1. 100명의 사용자가 입장 (세마포어 가득 참)
  2. 추가로 20명이 대기열 진입 시도
  3. admitUsersInActiveWaitingSchedules() 실행

예상 결과:
  ✅ 100명: 즉시 입장 성공 (admitted = true)
  ✅ 20명: 대기 상태 (admitted = false)
  ✅ 입장 처리 후 대기열 크기 유지: 20명

검증 완료:
  - 세마포어 기반 진입 제어 정상 동작
  - 대기열 입장 처리 메커니즘 정상 동작
```

---

### 테스트 요약

| 테스트 유형 | 검증 항목 | 사용자 수 | 결과 |
|------------|----------|----------|------|
| 단위 테스트 | 입장 제어 로직 (3가지) | - | ✅ 전체 통과 |
| 단위 테스트 | SSE 구독 검증 (3가지) | - | ✅ 전체 통과 |
| 단위 테스트 | 입장 처리 로직 (5가지) | - | ✅ 전체 통과 |
| 단위 테스트 | 이벤트/알림 (4가지) | - | ✅ 전체 통과 |
| 통합 테스트 | 세마포어 기반 대기열 처리 | 120명 | ✅ 100명 입장, 20명 대기 |

<br>
<br>
<br>

## 3. 잔액 충전/차감 동시성 제어
### 문제 상황
동일 사용자가 여러 기기나 탭에서 동시에 포인트를 충전하거나 차감할 때, Race Condition이 발생하여 최종 잔액이 부정확해질 수 있다. 예를 들어, 50개 스레드가 각각 100원씩 충전하면 5000원이 증가해야 하지만, 동시성 제어가 없으면 일부 충전이 누락될 수 있다.

### 해결 전략
**JPA Optimistic Lock (낙관적 락)**을 사용하여 애플리케이션 레벨에서 동시성 제어
- `@Version` 어노테이션을 사용한 버전 관리
- 트랜잭션 커밋 시점에 version 필드를 비교하여 충돌 감지
- 충돌 발생 시 `ObjectOptimisticLockingFailureException` 예외 발생
- `@Retryable`을 통해 충돌 시 최대 5회까지 자동 재시도 (지수 백오프: 100ms → 200ms → 400ms)
- 충전/차감 작업이 재시도 메커니즘을 통해 최종적으로 정합성 보장

**장점**:
- 동시성이 낮은 환경에서 락 대기 없이 높은 처리량 제공
- 데이터베이스 락을 사용하지 않아 리소스 효율적
- 읽기 작업이 블로킹되지 않음
- 코드 수정 최소화 (`@Version` 필드 추가 + `@Retryable` 설정)

**단점**:
- 동시성이 매우 높을 경우 재시도 횟수 증가로 성능 저하 가능
- 충돌이 빈번한 경우 비관적 락이 더 효율적일 수 있음

### 테스트 결과

#### 1) 도메인 테스트 (PointTest.java)
**목적**: 포인트 도메인 엔티티의 비즈니스 규칙 검증 <br>
**파일**: `PointTest.java`

| 카테고리 | 테스트 케이스 | 검증 내용 |
|---------|-------------|----------|
| **생성** | 정상적으로 포인트 생성 | userId, amount, updatedAt 필드 정상 생성 |
| | 금액 null 예외 | amount가 null이면 예외 발생 |
| | 회원ID null 예외 | userId가 null이면 예외 발생 |
| **충전** | 정상적으로 포인트 충전 | 0원 → 1000원 충전 성공 |
| | 보유 포인트 + 충전 금액 | 1000원 보유 → 1000원 충전 → 2000원 |
| | 100원 단위 제약 | 1001원 충전 시 예외 (100원 단위만 가능) |
| | 0원 충전 불가 | 0원 충전 시 예외 |
| **차감** | 정상적으로 포인트 사용 | 1000원 → 1000원 차감 → 0원 |
| | 잔액 부족 예외 | 보유 포인트보다 많이 사용 시 예외 |
| **환불** | 정상적으로 환불 | 1000원 → 1000원 환불 → 2000원 |
| | 환불 0원 불가 | 0원 환불 시 예외 |

**총 11개 테스트 케이스** - 전체 ✅ 통과

---

#### 2) 단위 테스트 (ChargePointServiceTest.java)
**목적**: Mock 객체를 활용한 충전 서비스 로직 검증 <br>
**파일**: `ChargePointServiceTest.java`

| 카테고리 | 테스트 케이스 | 검증 내용 |
|---------|-------------|----------|
| **예외 처리** | 존재하지 않는 회원 예외 | userId로 조회 실패 시 NoSuchElementException |
| **충전 로직** | 보유 포인트 0원 충전 | 0원 → 1000원 충전 시 결과 1000원 |

**총 2개 테스트 케이스** - 전체 ✅ 통과

---

#### 3) 통합 테스트 - 충전 동시성 (ChargePointConcurrencyTest.java)
**목적**: 실제 DB 환경에서 포인트 충전 동시성 제어 검증 <br>
**파일**: `ChargePointConcurrencyTest.java:41` <br>
**환경**: MySQL TestContainers + JPA Optimistic Lock

**테스트: 동일한 회원의 포인트를 동시에 충전하더라도 결과값이 정상적이어야 한다**
```
시나리오:
  1. 초기 잔액: 1000원 (userId=1)
  2. 50개 스레드가 동시에 100원씩 충전 시도
  3. 각 스레드는 독립적인 트랜잭션으로 실행

예상 결과:
  ✅ 최종 잔액: 1000 + (50 × 100) = 6000원
  ✅ 손실된 금액: 0원 (Race Condition 발생하지 않음)

동작 원리:
  - 각 스레드가 Point 엔티티 조회 시 version 필드도 함께 로드
  - 트랜잭션 커밋 시 version 충돌 발생
  - ObjectOptimisticLockingFailureException 발생 시 @Retryable로 자동 재시도
  - 최종적으로 모든 충전이 순차적으로 반영되어 1000 → 1100 → ... → 6000원 증가

검증 완료: Optimistic Lock + @Retryable이 동시성 문제 완전 방지
```

---

#### 4) 통합 테스트 - 차감 동시성 (DeductPointConcurrencyTest.java)
**목적**: 실제 DB 환경에서 포인트 차감 동시성 제어 검증 <br>
**파일**: `DeductPointConcurrencyTest.java` <br>
**환경**: MySQL TestContainers + JPA Optimistic Lock

**테스트 1: 동일한 회원의 포인트를 동시에 차감하더라도 결과값이 정상적이어야 한다 (line 44)**
```
시나리오:
  1. 초기 잔액: 10,000원 (userId=1)
  2. 50개 스레드가 동시에 100원씩 차감 시도

예상 결과:
  ✅ 최종 잔액: 10,000 - (50 × 100) = 5,000원
  ✅ 누락된 차감: 0원 (Race Condition 발생하지 않음)

검증 완료: Optimistic Lock + @Retryable로 차감 누락 방지
```

**테스트 2: 잔액 부족 시 일부 요청만 성공하고 나머지는 실패해야 한다 (line 94)**
```
시나리오:
  1. 초기 잔액: 1,000원 (userId=1)
  2. 20개 스레드가 동시에 100원씩 차감 시도 (총 2,000원 시도)

예상 결과:
  ✅ 성공 횟수: 10건 (1,000원 / 100원 = 10번)
  ✅ 실패 횟수: 10건 ("포인트가 부족합니다." 예외)
  ✅ 최종 잔액: 0원

검증 완료:
  - 잔액 부족 시 적절한 예외 발생
  - 실패한 트랜잭션은 롤백되어 데이터 정합성 유지
```

**테스트 3: 여러 사용자가 동시에 각자의 포인트를 차감해도 정상적으로 처리되어야 한다 (line 146)**
```
시나리오:
  1. 10명의 사용자 (userId: 0~9)
  2. 각자 초기 잔액: 5,000원
  3. 10개 스레드가 동시에 각자 1,000원씩 차감

예상 결과:
  ✅ 모든 사용자의 최종 잔액: 4,000원
  ✅ 사용자별 독립적인 락 획득으로 병렬 처리 가능

검증 완료: 다중 사용자 동시 처리 시 상호 간섭 없음
```

---

### 테스트 요약

| 테스트 유형 | 검증 항목 | 스레드 수 | 결과 |
|------------|----------|----------|------|
| 도메인 테스트 | 비즈니스 규칙 11가지 | - | ✅ 전체 통과 |
| 단위 테스트 | 충전 서비스 로직 | - | ✅ 전체 통과 |
| 통합 테스트 | 동시 충전 Race Condition 방지 | 50 | ✅ 6,000원 (손실 0) |
| 통합 테스트 | 동시 차감 Race Condition 방지 | 50 | ✅ 5,000원 (누락 0) |
| 통합 테스트 | 잔액 부족 시 일부 성공/실패 | 20 | ✅ 10건 성공, 10건 실패 |
| 통합 테스트 | 다중 사용자 동시 차감 | 10 | ✅ 사용자별 정확한 차감 |

<br>
<br>
<br>

## 4. 결제 처리 동시성 제어

### 문제 상황
동일한 좌석 홀딩에 대해 중복 결제 요청이 발생할 수 있다. 네트워크 지연, 클라이언트의 의도하지 않은 재시도, 또는 사용자의 중복 클릭으로 인해 같은 사용자가 동일한 좌석에 대해 여러 번 결제를 시도할 수 있다. 이 경우 중복 결제가 발생하여 포인트가 과다 차감되거나, 동일한 예약이 중복 생성될 수 있다.

### 해결 전략
**RDB 기반 멱등성 키 (Primary Key Constraint)**를 사용하여 중복 결제를 방지한다.

#### 1. **멱등성 키 선점 (RDB INSERT)**
- `PaymentIdempotency` 테이블의 `key` 필드를 Primary Key로 설정
- 클라이언트가 제공한 `idempotencyKey`로 INSERT 시도
- **성공**: 결제 로직 수행 시작 (PROCESSING 상태)
- **실패** (`DataIntegrityViolationException`): 중복 요청으로 판단

#### 2. **상태 관리 (3단계)**
```java
// PaymentIdempotencyJpaEntity.java:22-23
@Id
@Column(name ="key", length = 255)
private String key; // Primary Key → Unique Constraint 역할
```

| 상태 | 설명 | 처리 방식 |
|------|------|----------|
| **PROCESSING** | 결제 진행 중 | "중복된 요청입니다. 처리 중입니다." 예외 발생 |
| **SUCCESS** | 결제 완료 | 저장된 결과 JSON 반환 (멱등성 보장) |
| **FAILED** | 결제 실패 | "이전 요청이 실패했습니다. 새로운 멱등성 키로 재시도" 예외 발생 |

#### 3. **중복 요청 처리 흐름**
```java
// PayReservationService.java:70-72
boolean lockAcquired = tryLock(idempotencyKey, userId);
if (!lockAcquired)
    return handleDuplicateRequest(idempotencyKey);
```

**tryLock() 메커니즘** (PaymentIdempotencyRepositoryAdapter.java:21-33):
```java
try {
    PaymentIdempotencyJpaEntity entity = PaymentIdempotencyJpaEntity.from(paymentIdempotency);
    paymentIdempotencyJpaRepository.save(entity); // INSERT 시도
    return true; // 성공 → 락 획득
} catch (DataIntegrityViolationException e) {
    // Primary Key 중복 → 이미 처리 중이거나 완료
    return false; // 실패 → 중복 요청
}
```

**handleDuplicateRequest()** (PayReservationService.java:164-178):
- PROCESSING 상태: 예외 발생 (409 Conflict)
- SUCCESS 상태: 저장된 `resultData` JSON을 역직렬화하여 반환
- FAILED 상태: 예외 발생 (새 멱등성 키로 재시도 안내)

#### 4. **결과 저장 및 조회**
```java
// 결제 성공 시 (PayReservationService.java:94)
paymentIdempotencyRepositoryPort.setResult(
    idempotencyKey,
    result.getId(),
    objectMapper.writeValueAsString(payReservationResult) // JSON 직렬화
);

// 중복 요청 시 저장된 결과 반환 (PayReservationService.java:188-209)
PayReservationResult result = objectMapper.readValue(
    idempotency.getResultData(),
    PayReservationResult.class
);
```

### Redis vs RDB 멱등성 비교

| 구분 | 좌석 홀딩 (Redis) | 결제 처리 (RDB) |
|------|------------------|----------------|
| **저장소** | Redis (`setIfAbsent`) | MySQL (Primary Key) |
| **메커니즘** | Redis Atomic 연산 | `DataIntegrityViolationException` |
| **TTL** | 1시간 (자동 만료) | 영구 저장 |
| **목적** | 빠른 응답, 임시 잠금 | 감사 추적, 트랜잭션 보장 |
| **장애 복구** | TTL 만료로 자동 해결 | 영구 저장으로 이력 추적 가능 |
| **조회 성능** | 매우 빠름 (In-Memory) | 상대적으로 느림 (Disk I/O) |
| **데이터 정합성** | Redis 재시작 시 손실 가능 | DB 트랜잭션으로 보장 |

**선택 기준**:
- **좌석 홀딩**: 임시 잠금 + 자동 만료 필요 → Redis 선택
- **결제 처리**: 금융 거래 + 영구 이력 추적 필요 → RDB 선택

### 장점
- **데이터베이스 트랜잭션과 통합**: 결제-예약 생성이 트랜잭션 내에서 원자성 보장
- **영구 저장**: 멱등성 이력을 영구 저장하여 감사(Audit) 및 문제 추적 가능
- **Redis 장애 독립성**: Redis 장애 시에도 결제 멱등성 보장
- **중복 결제 완전 방지**: Primary Key Constraint로 DB 레벨에서 중복 차단
- **결과 캐싱**: SUCCESS 상태의 결과 JSON 저장으로 재요청 시 즉시 응답

### 단점
- **응답 속도**: Redis 대비 느림 (Disk I/O 발생)
- **DB 부하**: 결제 요청마다 INSERT/UPDATE 발생
- **테이블 크기 증가**: 멱등성 레코드가 영구 저장되어 관리 필요
  - 개선 방안: 스케줄러로 N일 이전 레코드 삭제 (idx_created_at 인덱스 활용)

### 테스트 결과

#### 1) 통합 테스트 - TTL 만료 후 결제 실패 (PaymentDelayTest.java)
**목적**: 좌석 홀딩 TTL 만료 후 결제 시도 시 실패 검증 <br>
**파일**: `PaymentDelayTest.java:35`

**테스트: 좌석 홀딩 후 TTL 만료시 결제가 실패해야 한다**
```
시나리오:
  1. 좌석 1L, 2L 홀딩 (userId=100, scheduleId=1)
  2. Redis 홀딩 키 TTL을 1초로 단축 (hold:1:1, hold:1:2)
  3. 1.1초 대기 → TTL 만료 → Redis에서 홀딩 정보 삭제
  4. 결제 시도 (동일 사용자, 동일 좌석)

예상 결과:
  ✅ IllegalStateException 발생
  ✅ 에러 메시지: "예약 대기 중인 좌석이 없습니다."
  ✅ 결제 처리 실패 (홀딩 정보 없음)

검증 완료:
  - 홀딩 TTL 만료 시 결제 불가 (데이터 정합성 보장)
  - 멱등성 키는 FAILED 상태로 저장됨
```

---

#### 2) 통합 테스트 - 동시성 제어 (PaymentConcurrencyIntegrationTest.java)
**목적**: 실제 DB 환경에서 결제 멱등성 키 기반 동시성 제어 검증 <br>
**파일**: `PaymentConcurrencyIntegrationTest.java:51` <br>
**환경**: MySQL TestContainers + RDB Primary Key Constraint

**테스트: 동일한 멱등성 키로 동시에 결제 요청 시 한 건만 성공해야 한다**
```
시나리오:
  1. 사용자 (userId=100)가 좌석 1L, 2L 홀딩 (scheduleId=1)
  2. 100개 스레드가 동일한 멱등성 키로 동시 결제 시도
  3. 각 스레드는 독립적인 트랜잭션으로 실행

예상 결과:
  ✅ 성공: 1건 (멱등성 키 INSERT 성공)
  ✅ 실패: 99건 (DataIntegrityViolationException → "중복된 요청입니다. 처리 중입니다." 예외)
  ✅ 최종 결제 레코드: 1건만 생성
  ✅ 포인트 차감: 1회만 수행

동작 원리:
  - 첫 번째 요청이 PaymentIdempotency 테이블에 INSERT 성공 (PRIMARY KEY 획득)
  - 나머지 99개 요청은 DataIntegrityViolationException 발생
  - tryLock()이 false 반환 → handleDuplicateRequest() 호출
  - PROCESSING 상태 확인 후 "중복된 요청입니다." 예외 발생

검증 완료: RDB Primary Key Constraint 기반 멱등성 제어 정상 동작
```

---

### 테스트 요약

| 테스트 유형 | 검증 항목 | 스레드 수 | 결과 |
|------------|----------|----------|------|
| 통합 테스트 | TTL 만료 후 결제 실패 | 1 | ✅ "예약 대기 중인 좌석이 없습니다." 예외 |
| 통합 테스트 | 동일 멱등성 키 동시 결제 | 100 | ✅ 1건 성공, 99건 중복 요청 예외 |